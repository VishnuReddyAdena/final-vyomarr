import React, { useEffect, useRef, useState } from "react";
import "./PuzzlesGames.css";

const SHAPES = [
  [[1, 1, 1, 1]], // I
  [[1, 1], [1, 1]], // O
  [[0, 1, 0], [1, 1, 1]], // T
  [[1, 1, 0], [0, 1, 1]], // Z
  [[0, 1, 1], [1, 1, 0]], // S
  [[1, 0, 0], [1, 1, 1]], // J
  [[0, 0, 1], [1, 1, 1]], // L
];

export default function PuzzlesGamesPage() {
  const canvasRef = useRef(null);
  const daysRef = useRef(null);
  const hoursRef = useRef(null);
  const minsRef = useRef(null);
  const terminalRef = useRef(null);

  // stable refs for timers/animation
  const animIdRef = useRef(null);
  const resizeObserverRef = useRef(null);
  const countdownIntervalRef = useRef(null);
  const logTimeoutRefs = useRef(new Set());

  // email state (optional)
  const [email, setEmail] = useState("");

  /* ---------------------------
     Canvas / Tetris effect
     --------------------------- */
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext("2d");

    let width = 0;
    let height = 0;
    const blockSize = 30;
    const blocks = [];

    function setSize() {
      const dpr = window.devicePixelRatio || 1;
      width = Math.floor(window.innerWidth);
      height = Math.floor(window.innerHeight);
      canvas.style.width = width + "px";
      canvas.style.height = height + "px";
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // scale drawing operations
    }

    function resizeHandler() {
      setSize();
      // reposition existing blocks to remain on-screen (optional)
    }

    window.addEventListener("resize", resizeHandler);
    setSize();

    class FallingBlock {
      constructor() { this.reset(); }
      reset() {
        this.shape = SHAPES[Math.floor(Math.random() * SHAPES.length)];
        const cols = Math.max(1, Math.floor(width / blockSize));
        this.x = Math.floor(Math.random() * cols) * blockSize;
        this.y = -150 - Math.random() * 200;
        this.speed = 1 + Math.random() * 1.5;
        this.isOrange = Math.random() > 0.9;
        this.opacity = 0.1 + Math.random() * 0.2;
      }
      update() {
        this.y += this.speed;
        if (this.y > height) this.reset();
      }
      draw() {
        ctx.strokeStyle = this.isOrange
          ? `rgba(252, 76, 0, ${this.opacity})`
          : `rgba(31, 92, 255, ${this.opacity})`;
        ctx.lineWidth = 1.5;
        ctx.shadowBlur = 0;
        for (let r = 0; r < this.shape.length; r++) {
          for (let c = 0; c < this.shape[r].length; c++) {
            if (!this.shape[r][c]) continue;
            const bx = this.x + c * blockSize;
            const by = this.y + r * blockSize;
            ctx.strokeRect(bx + 2, by + 2, blockSize - 4, blockSize - 4);
            ctx.fillStyle = this.isOrange ? "rgba(252,76,0,0.05)" : "rgba(31,92,255,0.02)";
            ctx.fillRect(bx + 2, by + 2, blockSize - 4, blockSize - 4);
          }
        }
      }
    }

    for (let i = 0; i < 15; i++) blocks.push(new FallingBlock());

    function animate() {
      ctx.clearRect(0, 0, width, height);

      // faint grid
      ctx.strokeStyle = "rgba(255,255,255,0.03)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      for (let x = 0; x <= width; x += blockSize) { ctx.moveTo(x, 0); ctx.lineTo(x, height); }
      for (let y = 0; y <= height; y += blockSize) { ctx.moveTo(0, y); ctx.lineTo(width, y); }
      ctx.stroke();

      blocks.forEach(b => { b.update(); b.draw(); });

      animIdRef.current = requestAnimationFrame(animate);
    }

    animate();

    return () => {
      window.removeEventListener("resize", resizeHandler);
      if (animIdRef.current) cancelAnimationFrame(animIdRef.current);
      // clear any log timeouts (should be handled elsewhere too)
      for (const t of logTimeoutRefs.current) clearTimeout(t);
      logTimeoutRefs.current.clear();
    };
  }, []);

  /* ---------------------------
     Countdown
     --------------------------- */
  useEffect(() => {
    const launchTime = new Date("2026-01-15T12:00:00+05:30").getTime();
    function updateCountdown() {
      const now = Date.now();
      const diff = launchTime - now;
      if (diff < 0) {
        // optional: show "Launched" state
        return;
      }
      const d = Math.floor(diff / 86400000);
      const h = Math.floor((diff % 86400000) / 3600000);
      const m = Math.floor((diff % 3600000) / 60000);
      if (daysRef.current) daysRef.current.textContent = d.toString().padStart(2, "0");
      if (hoursRef.current) hoursRef.current.textContent = h.toString().padStart(2, "0");
      if (minsRef.current) minsRef.current.textContent = m.toString().padStart(2, "0");
    }
    updateCountdown();
    countdownIntervalRef.current = setInterval(updateCountdown, 60_000);
    return () => {
      if (countdownIntervalRef.current) clearInterval(countdownIntervalRef.current);
    };
  }, []);

  /* ---------------------------
     Terminal logs
     --------------------------- */
  useEffect(() => {
    const logs = [
      "<span>[OK]</span> Initializing Vyomarr Core...",
      "<span>[SYS]</span> Loading block logic...",
      "<span>[NET]</span> Syncing quiz database...",
      "<span>[OPT]</span> Adjusting gravity...",
      "<span>[RUN]</span> Establishing secure link...",
      "<span>[OK]</span> Ready for user input."
    ];
    const term = terminalRef.current;
    if (!term) return;

    let logIndex = 0;
    let cleared = false;

    const addLog = () => {
      if (cleared) return;
      if (logIndex >= logs.length) {
        const t = setTimeout(() => {
          if (cleared) return;
          term.innerHTML = "";
          logIndex = 0;
          addLog();
        }, 6000);
        logTimeoutRefs.current.add(t);
        return;
      }
      const div = document.createElement("div");
      div.className = "log-line";
      div.innerHTML = `> ${logs[logIndex]}`; // safe here if logs are static
      term.appendChild(div);
      term.scrollTop = term.scrollHeight;
      logIndex++;
      const t = setTimeout(addLog, 400 + Math.random() * 1000);
      logTimeoutRefs.current.add(t);
    };

    const startTimeout = setTimeout(addLog, 1000);
    logTimeoutRefs.current.add(startTimeout);

    return () => {
      cleared = true;
      for (const t of logTimeoutRefs.current) clearTimeout(t);
      logTimeoutRefs.current.clear();
    };
  }, []);

  /* ---------------------------
     Form submit (example)
     --------------------------- */
  const handleSubmit = (e) => {
    e.preventDefault();
    // TODO: send to backend or service
    console.log("subscribe", email);
    // feedback to user: clear or show success message
    setEmail("");
    alert("Thanks — we'll keep you posted.");
  };

  return (
    <>
      <div id="navbar" />
      <canvas id="tetris-canvas" ref={canvasRef} />
      <div className="vignette-overlay" />

      <main className="container" role="main">
        <div className="status-badge">Status: Under Construction</div>
        <div className="brand-logo">VYOMARR</div>
        <h1>Puzzles &amp; Games Incoming</h1>
        <div className="sub-headline">You&apos;re early. That&apos;s rare.</div>
        <p className="main-copy">
          Vyomarr Puzzles &amp; Games is currently compiling. The challenges we&apos;re crafting are designed to mess with your instincts, hijack your dopamine, and force your brain to level up.
        </p>

        <div className="loading-zone">
          <div className="progress-track">
            <div className="progress-fill" />
          </div>
          <div className="progress-info">
            <span>System Build v0.9</span>
            <span>Phase 1 In Progress...</span>
          </div>
        </div>

        <div className="grid-deck">
          <div className="glass-card">
            <span className="card-meta">Phase 1</span>
            <div className="card-title">Fast Space Quizzes</div>
            <div className="card-desc">Short questions on rockets, orbits, and black holes — easy to try, hard to master.</div>
          </div>
          <div className="glass-card">
            <span className="card-meta">Phase 2</span>
            <div className="card-title">Logic &amp; Trajectories</div>
            <div className="card-desc">Solve simple orbit and thrust puzzles. Learn how things actually move in space.</div>
          </div>
          <div className="glass-card">
            <span className="card-meta">Phase 3</span>
            <div className="card-title">Challenge Modes</div>
            <div className="card-desc">Timed missions and score-based games. Replay to beat your own personal best.</div>
          </div>
        </div>

        <div className="dashboard-row">
          <div className="widget" aria-label="Estimated launch">
            <div className="terminal-header">EST. LAUNCH</div>
            <div className="cd-grid">
              <div>
                <span className="cd-val" ref={daysRef}>00</span>
                <span className="cd-lbl">Days</span>
              </div>
              <div>
                <span className="cd-val" ref={hoursRef}>00</span>
                <span className="cd-lbl">Hrs</span>
              </div>
              <div>
                <span className="cd-val" ref={minsRef}>00</span>
                <span className="cd-lbl">Min</span>
              </div>
            </div>
          </div>

          <div className="widget" style={{ justifyContent: "flex-start" }}>
            <div className="terminal-header">
              <span>BUILD LOG</span>
              <span className="live-status">● LIVE</span>
            </div>
            <div className="terminal-body" ref={terminalRef} aria-live="polite" />
          </div>
        </div>

        <form className="capture-form" onSubmit={handleSubmit}>
          <label className="capture-label" htmlFor="email">Stay sharp. Drop your email so you don't miss launch:</label>
          <div className="input-group">
            <input
              id="email"
              aria-label="Email address"
              type="email"
              placeholder="Enter your email address..."
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              required
            />
            <button type="submit" className="primary-btn">Stay Sharp</button>
          </div>
        </form>

        <div className="nav-links">
          <button className="ghost-btn" onClick={() => window.history.back()}>← Back to Main Site</button>
          <button className="ghost-btn">Latest Articles</button>
        </div>
      </main>

      <div id="footer" />
    </>
  );
}
